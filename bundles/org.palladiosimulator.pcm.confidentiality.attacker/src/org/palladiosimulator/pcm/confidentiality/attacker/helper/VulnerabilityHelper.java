package org.palladiosimulator.pcm.confidentiality.attacker.helper;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.AttackerSystemSpecificationContainer;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.Mitigation;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.Attack;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.AttackVector;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.ConfidentialityImpact;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.Role;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.Vulnerability;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.pcmIntegration.AttackVectorIntegration;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.pcmIntegration.PCMElement;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.pcmIntegration.RoleSystemIntegration;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.pcmIntegration.VulnerabilitySystemIntegration;
import org.palladiosimulator.pcm.confidentiality.context.system.pcm.structure.MethodSpecification;
import org.palladiosimulator.pcm.core.composition.AssemblyContext;
import org.palladiosimulator.pcm.resourceenvironment.LinkingResource;
import org.palladiosimulator.pcm.resourceenvironment.ResourceContainer;

public final class VulnerabilityHelper {
    private VulnerabilityHelper() {
        assert false;
    }

    /**
     * Checks whether an attack is possible and returns the {@link Vulnerability} with the highest
     * impact on Confidentiality. If the vulnerabilities contain multiple vulnerabilities with
     * highest impact it returns any vulnerability of it
     *
     * @param credentials
     * @param policies
     * @param vulnerabilities
     * @param attacks
     * @param vector
     * @return {@link Vulnerability} with the highest ConfidentialityImpact if no attack is possible
     *         null
     */
    public static Vulnerability checkAttack(boolean authenticated, final List<Vulnerability> vulnerabilities,
            final List<Attack> attacks, final AttackVector vector, List<Role> roles) {
        final var applicableVulnerabilities = new ArrayList<Vulnerability>();
        for (final var vulnerability : vulnerabilities) {
            for (final var attack : attacks) {

                if (attack.canExploit(vulnerability, authenticated, vector)) {
                    if (vulnerability.getConfidentialityImpact() == ConfidentialityImpact.HIGH) {
                        return vulnerability;
                    }
                    applicableVulnerabilities.add(vulnerability);
                }

            }
        }
        final var returnValue = applicableVulnerabilities.stream()
                .filter(e -> e.getConfidentialityImpact() == ConfidentialityImpact.LOW).findAny();
        if (returnValue.isPresent()) {
            return returnValue.get();
        }
        return applicableVulnerabilities.stream().findAny().orElse(null);
    }

    public static List<Vulnerability> getVulnerabilities(
            final AttackerSystemSpecificationContainer vulnerabilityspecification, final ResourceContainer resource) {

        var listVulnerabilitySystemIntegration = filterSystemSpecification(vulnerabilityspecification);
        return getVulnerabilities(listVulnerabilitySystemIntegration, resource);
    }

    private static List<VulnerabilitySystemIntegration> filterSystemSpecification(
            final AttackerSystemSpecificationContainer vulnerabilityspecification) {
        return vulnerabilityspecification.getVulnerabilities().stream()
                .filter(VulnerabilitySystemIntegration.class::isInstance)
                .map(VulnerabilitySystemIntegration.class::cast).collect(Collectors.toList());
    }

    public static List<RoleSystemIntegration> getRoles(
            final AttackerSystemSpecificationContainer vulnerabilityspecification) {
        return vulnerabilityspecification.getVulnerabilities().stream().filter(RoleSystemIntegration.class::isInstance)
                .map(RoleSystemIntegration.class::cast).collect(Collectors.toList());
    }
    
    public static List<Mitigation> getMitigations(
            final AttackerSystemSpecificationContainer vulnerabilityspecification) {
        return vulnerabilityspecification.getVulnerabilities().stream().filter(Mitigation.class::isInstance)
                .map(Mitigation.class::cast).collect(Collectors.toList());
    }
    
    public static List<AttackVectorIntegration> getAttackVector(
            final AttackerSystemSpecificationContainer vulnerabilityspecification) {
        return vulnerabilityspecification.getVulnerabilities().stream().filter(AttackVectorIntegration.class::isInstance)
                .map(AttackVectorIntegration.class::cast).collect(Collectors.toList());
    }

    public static List<Vulnerability> getVulnerabilities(
            final List<VulnerabilitySystemIntegration> vulnerabilitySpecification, final ResourceContainer resource) {
        return getVulnerbilities(vulnerabilitySpecification, PCMElement::getResourcecontainer, resource);
    }

    public static List<Vulnerability> getVulnerabilities(
            final AttackerSystemSpecificationContainer vulnerabilityspecification, final AssemblyContext component) {
        var listVulnerabilitySystemIntegration = filterSystemSpecification(vulnerabilityspecification);
        return getVulnerabilities(listVulnerabilitySystemIntegration, component);
    }

    public static List<Vulnerability> getVulnerabilities(
            final AttackerSystemSpecificationContainer vulnerabilityspecification,
            final MethodSpecification methodSpecification) {
        var listVulnerabilitySystemIntegration = filterSystemSpecification(vulnerabilityspecification);
        return getVulnerabilities(listVulnerabilitySystemIntegration, methodSpecification);
    }

    public static List<Vulnerability> getVulnerabilities(
            final List<VulnerabilitySystemIntegration> vulnerabilitySpecification,
            final MethodSpecification methodSpecification) {
        return getVulnerbilities(vulnerabilitySpecification, PCMElement::getMethodspecification, methodSpecification);
    }

    public static List<Vulnerability> getVulnerabilities(
            final List<VulnerabilitySystemIntegration> vulnerabilitySpecification, final AssemblyContext component) {
        return getVulnerbilities(vulnerabilitySpecification, PCMElement::getAssemblycontext, component);
    }

    public static List<Vulnerability> getVulnerabilities(
            final AttackerSystemSpecificationContainer vulnerabilityspecification, final LinkingResource resource) {
        var listVulnerabilitySystemIntegration = filterSystemSpecification(vulnerabilityspecification);
        return getVulnerabilities(listVulnerabilitySystemIntegration, resource);
    }

    public static List<Vulnerability> getVulnerabilities(
            final List<VulnerabilitySystemIntegration> vulnerabilitySpecification, final LinkingResource resource) {
        return getVulnerbilities(vulnerabilitySpecification, PCMElement::getLinkingresource, resource);
    }

    private static List<Vulnerability> getVulnerbilities(final List<VulnerabilitySystemIntegration> specification,
            final Function<PCMElement, EObject> method, final EObject object) {
        return specification.stream().filter(e -> EcoreUtil.equals(method.apply(e.getPcmelement()), object))
                .map(VulnerabilitySystemIntegration::getVulnerability).collect(Collectors.toList());
    }

}
